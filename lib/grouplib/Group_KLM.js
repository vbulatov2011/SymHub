import {
    iPlane,
    iSphere,
    iReflectU4,
    abs,
    sin,
    cos,
    sqrt,
    PI,
    Group,
    splaneToString,
    objectToString,
    ParamInt,
    EventProcessor, 
}
from './modules.js'

const EPSILON2 = 1.e-4;
const EPSILON = 1.e-6;
const DEBUG = true;
const MY_NAME = 'Group_KLM';

/*
provides generators for reflection groups generated by 3 reflections
 */
export class Group_KLM {

    constructor() {

        this.params = {
            K: 3,
            L: 4,
            M: 3,
        };
        
        this.mParams = this.makeParams();
                
    }

    /**
    return map of current parameters
     */
    getParamsMap() {

        var p = this.params;

        return {
            K: p.K,
            L: p.L,
            M: p.M,
        };
    }

    setOptions(opt){
        if(opt.onChanged){
            this.onGroupChanged = opt.onChanged;
            this.eventProcessor = new EventProcessor();
            this.eventProcessor.addEventListener('onChanged', this.onGroupChanged);
        }                
    }
    //
    //  return external params 
    //
    getParams(){
        return this.mParams;
      
    }
        
    makeParams(){
        var par = this.params;
        var opc = this.onParamChanged.bind(this);
        
        return {
          K: 
                ParamInt({
                      obj:   par,
                      key:  'K',                      
                      min: 0, max: 20,
                      onChange: opc,
                }),
          L: 
                ParamInt({
                      obj:   par,
                      key:  'L',   
                      min: 0, max: 20,
                      onChange: opc,
                }),
          M: 
                ParamInt({
                      obj:   par,
                      key:  'M',                      
                      min: 0, max: 20,
                      onChange: opc,
                }),
        };
   }  // makeParams
   
    //
    // called from UI when any group param was changed 
    //
    onParamChanged(){
        if(DEBUG)console.log(this.constructor.name + '.onParamChanged()', 'eventProcessor:', this.eventProcessor);
        if(this.eventProcessor){
            this.eventProcessor.handleEvent({type:'onChanged', target: this});
        }
    
    }

    /**
    set parameters from saved paramMap
     */
    setParamsMap(paramsMap) {

        this.controllers.K.setValue(paramsMap.K);
        this.controllers.L.setValue(paramsMap.L);
        this.controllers.M.setValue(paramsMap.M);

    }

    initGUI(options) {

        var gui = options.gui;
        var folder = options.folder;
        var onc = options.onChanged;
        var par = this.params;
        this.controllers = {};

        this.controllers.K = folder.add(par, 'K', 0, 20, 1).onChange(onc);
        this.controllers.L = folder.add(par, 'L', 0, 20, 1).onChange(onc);
        this.controllers.M = folder.add(par, 'M', 0, 20, 1).onChange(onc);

        gui.remember(par);

    }

    //
    //  return group description
    //
    getGroup() {

        var par = this.params;
        if (DEBUG)
            console.log('getGroup: %d %d %d', par.K, par.L, par.M);

        var tri = this.getFD();

        var trans = [];
        var S0 = tri[0];
        var S1 = tri[1];
        var S2 = tri[2];
        var S1a = iReflectU4(S0, S1);
        var S2a = iReflectU4(S0, S2);
        
        var fd = [S1, S2, S1a, S2a];
        if(DEBUG) console.log('%s fd: ', MY_NAME, 
                        splaneToString(fd[0]),
                        splaneToString(fd[1]),
                        splaneToString(fd[2]),
                        splaneToString(fd[3]),
                        );
        if(DEBUG) console.log('%s fd: ', MY_NAME, objectToString(fd));
        var trans = [[S1, S0], [S2, S0], [S0, S1], [S0, S2]];
        let group = new Group({s: fd, t: trans});
        
        if(DEBUG) console.log('%s return: ', MY_NAME, group);
        return group;

    }

    //
    //  return the fundamental domain
    //
    getFD() {

        var par = this.params;
        return this.makeTriangle(this.getAngle(par.K), this.getAngle(par.L), this.getAngle(par.M));

    }

    makeTriangle(a0, a1, a2) {

        if(DEBUG) console.log('%s.makeTriangle(%f,%f,%f)', MY_NAME, a0/PI, a1/PI, a2/PI);
        
        if (abs(a0) < EPSILON) {
            return this.makeIdealTriangle(a0, a1, a2);
        }
        var factor = a0 + a1 + a2;

        if (DEBUG)
            console.log("Group_KLM factor: %f", factor);

        if (abs(factor - PI) < EPSILON) {
            return this.makeEuclideanTriangle(a0, a1, a2);
        } else if (factor > PI + EPSILON) {
            return this.makeSphericalTriangle(a0, a1, a2);
        } else {
            return this.makeHyperbolicTriangle(a0, a1, a2);
        }

    }

    makeEuclideanTriangle(a0, a1, a2) {

        var e = 0.25; // size of triangle
        if(DEBUG) console.log('%s.makeEuclideanTriangle(%f,%f,%f)', MY_NAME, a0/PI, a1/PI, a2/PI);

        return [
            iPlane([0., -1., 0., 0.]),
            iPlane([-sin(a0), cos(a0), 0., 0.]),
            iPlane([sin(a1), cos(a1), 0., e])
        ];

    }

    makeSphericalTriangle(a0, a1, a2) {

        if(DEBUG) console.log('%s.makeSphericalTriangle(%f,%f,%f)', MY_NAME, a0/PI, a1/PI, a2/PI);

        var s = []; // sides of FD
        s[0] = iPlane([0., -1., 0., 0.]);
        s[1] = iPlane([-sin(a0), cos(a0), 0., 0.]);

        var e2 = 0.25; // size of triangle

        var r = e2 * sin(a0) / (cos(a2) + cos(a1 + a0));
        var cx = r * (cos(a2) + cos(a1) * cos(a0)) / sin(a0);
        var cy = r * cos(a1);

        s[2] = iSphere([cx, cy, 0, -r]);
        return s;
    }

    makeHyperbolicTriangle(a0, a1, a2) {

        if(DEBUG) console.log('%s.makeHyperbolicTriangle(%f,%f,%f)', MY_NAME, a0/PI, a1/PI, a2/PI);
        var s = [];
        s[0] = iPlane([0., -1., 0., 0.]);
        s[1] = iPlane([-sin(a0), cos(a0), 0., 0.]);

        var ax = (cos(a2) + cos(a1) * cos(a0)) / sin(a0);
        var ay = cos(a1);

        var r = 1. / sqrt(ax * ax + ay * ay - 1.);

        var cx = r * ax;
        var cy = r * ay;
        s[2] = iSphere([cx, cy, 0, -r]);

        return s;
    }

    //
    //
    //  special case with a0 = 0;
    //   we set   splane[0] = plane ((0,-1,0),0)
    //            splane[1] = sphere((-1,1,0),1)
    //            splane[2] = sphere or plane which intersect s0 and s1 with given angles
    //
    makeIdealTriangle(a0, a1, a2) {

        var s = [];
        s[0] = iPlane([0., -1., 0., 0.]);
        s[1] = iSphere([-1., 1., 0., -1.]);

        //fd.s[1] = iPlane(vec3(0.,1., 0.),2.);
        var denum = (cos(a1) + cos(a2));
        if (abs(denum) < EPSILON) {
            // vertical line
            s[2] = iSphere([0., 0., 0., 1.]);
            return s;
        }

        var r3 = 2. / denum;
        var x3 = 1.;
        var y3 = r3 * cos(a1);
        //  invert in the sphere S3 = S((-1,0), 2)
        var dd = ((x3 + 1.) * (x3 + 1.) + y3 * y3 - r3 * r3);

        if (abs(dd) > EPSILON2) {
            var a = 4. / dd;
            x3 = -1. + a * (x3 + 1.);
            y3 *= a;
            r3 *= a;
            s[2] = iSphere([x3, y3, 0, -r3]);
        } else {
            // special case when inversion center (-1,0) belong to the sphere S3
            if (abs(a2) < EPSILON) {
                // case when a1 = pi/2, a2 = 0
                s[2] = iPlane([1., 0., 0, 0.]);
            } else {
                // case when a1 = pi/4, a2 = pi/2
                s[2] = iPlane([1., 1., 0, 0.]);
            }
        }
        return s;

    } // makeIdealTriangle(a0, a1, a2)


    //
    //  convert fraction to angle
    //
    getAngle(fraction) {

        if (fraction >= 20 || fraction < 2)
            return 0;
        else
            return Math.PI / fraction;
    }

} // class Group_KLM
